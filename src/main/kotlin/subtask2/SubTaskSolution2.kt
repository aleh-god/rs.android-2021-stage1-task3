package subtask2

import kotlin.math.*

fun main(args: Array<String>) {

    var x = decomposeNumber(50)
    x?.forEach { it -> print(" $it ") }
    println("\nПравильный ответ: 1, 3, 5, 8, 49") // 1, 3, 5, 8, 49

    x = decomposeNumber(7100)
    x?.forEach { it -> print(" $it ") }
    println("\nПравильный ответ: 2, 3, 5, 119, 7099")

    x = decomposeNumber(1234567)
    x?.forEach { it -> print(" $it ") }
    println("\nПравильный ответ: 2, 8, 32, 1571, 1234566")

    x = decomposeNumber(7654321)
    x?.forEach { it -> print(" $it ") }
    println("\nПравильный ответ: 6, 10, 69, 3912, 7654320")

}

private fun decomposeNumber(number: Int): Array<Int>? {

    val funResult: MutableList<Int>? = decompose2(number.toDouble())
    var result: Array<Int>? = null

    if (funResult == null) return null
    else result = funResult.toTypedArray<Int>()

    return result
}

// это функция, которая вызывает это с аргументами n² а также n - 1:
fun decompose2(n: Double): MutableList<Int>? {
    val nn = n - 1
    return decompose2Rec(nn, n * n) // 49 2500
}

// это рекурсивная функция для поиска отдельных квадратов не больше, чем c что в сумме n.
fun decompose2Rec(i: Double, tot: Double): MutableList<Int>? {
    println()
    println("Start $i and $tot")

    // Теперь нам нужно убедиться, что рекурсия завершилась:
    // Убедитесь, что мы не тратим время на поиск решений, в которых n - c² становится отрицательным:
    if (tot == 0.0) {
        println("return mutableListOf()")
        return mutableListOf()
    }

    if (i <= 0.0 || tot < 1.0) {
        println("i <= 0.0 || tot < 1.0 return null")
        return null
    }

    var tempTot = tot - i * i
    println("tempTot = остаток от вычитания квадрата $i = $tempTot")
    var temp = sqrt(tempTot)
    temp = floor(temp)
    println("floor(temp) = квадратный корень остатка = $temp")

    if (i == temp || i < temp) {
        println("i == temp return null")
        return null
    }

    println("decompose2Rec($temp, ${tot - i * i})")
    val subList = decompose2Rec(temp, tot - i * i)

    if (subList != null) {
        subList.add(i.toInt())
        println("subList.add(i) $i")
        println("return subList")
        return subList
    }

    println("Вернулся null, запускаем decompose2Rec(${i - 1}, ${tot})")
    return decompose2Rec(i - 1, tot)
}


/*

Обычно это ситуация для рекурсия, ожидая результата меньшей проблемы:

Начнем с кандидатов от n-1 до 1.
каждый кандидат либо добавлен, либо нет
если добавлено и результат для остальных найден, добавить и вернуть с окончательным результатом
в противном случае попробуйте меньших кандидатов

Улучшение скорости можно сделать, учитывая квадратный корень из tot в качестве следующего кандидата, если он меньше, чем n - count - 1.

Найдите набор различных чисел, каждое не больше C, для которых
     сумма квадратов к N.
     Возвращает список в числовом порядке.
     Если такого набора не существует, верните None.




Квадратный Декомпозитор

Моя младшая сестра вернулась домой из школы со следующей задачей: получив квадратный лист бумаги, она должна разрезать его на части,
которые при сборке дают квадраты, стороны которых образуют возрастающую последовательность чисел.
Вначале это было очень весело, но мало-помалу мы устали видеть груду разорванной бумаги.
Поэтому мы решили написать программу, которая могла бы помочь нам и защитить деревья.

Задача

Дано положительное целое число n, вернуть строго возрастающую последовательность (массив) чисел, чтобы сумма квадратов была равна n².

Если существует несколько решений (а их будет), верните, насколько это возможно, результат с максимально возможными значениями:

Примеры

разложить 11 должен вернуть [1, 2, 4, 10]. Обратите внимание, что на самом деле есть два способа разложить
11², 11² = 121 = 1 + 4 + 16 + 100 = 1² + 2² + 4² + 10², но не возвращайте [2, 6, 9], так как 9 меньше 10.

Для разложения 50 не возвращайте [1, 1, 4, 9, 49], но [1, 3, 5, 8, 49], поскольку [1, 1, 4, 9, 49] не формируют строго возрастающую последовательность. .

Примечание

Ни [n], ни [1, 1, 1,…, 1] не являются допустимыми решениями. Если действительного решения не существует, верните ноль.

Функция «разложить» примет положительное значение Int n и вернет разложение N = n² как [x1 ... xk]

Если n отрицательное, также верните null.

Примеры:

разложить 50 результатов [1, 3, 5, 8, 49]

разложить 4 возвращает ноль

Старт всегда один
Прыгаем от массива, который просчитывает цепочку и выдает результат
Закончится должно все 1 или 0

50
49 48 47 ... 20 19 ... 5 4 3 2 1

11
10 9 8 7 6 5 4 3 2 1

11
10 4 2 1

121
100 16 4 1

 */